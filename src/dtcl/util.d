/** A Wrapper module of Tcl.
Dmd:        2.071.0
Date:       2016-Apr-10 17:34:58
Authors: KUMA
License: CC0
 **/
module dtcl.util;

private import dtcl.binding;
private import sworks.base.malloc;
debug private import std.stdio;
debug private import std.conv : to;

//------------------------------------------------------------------------------
// 例外関連
//------------------------------------------------------------------------------
/** A function like std.exception.enforce.

Add additional messages generated by Tcl to the exception.

概要:
std.exception.enforce みたいなん。

詳細:
Tclのエラーメッセージを追加する。
**/
T enOK(T, U)(T result, U interp = null, lazy string msg = "enOK failed.",
             string file = __FILE__, size_t line = __LINE__)
    if (is(U : Tcl_Interp*) || is(U : Tcl))
{
    static if      (is(T == bool))
    {
        if (result) return result;
    }
    else static if (is(T : int))
    {
        if (result != TCL_ERROR) return result;
    }
    else static if (is(T : U*, U))
    {
        if (result !is null) return result;
    }
    else static assert(0, "enOK() needs an implementation for " ~ T.stringof);

    if (interp is null)
        throw new Exception("TCL_ERROR: " ~ msg, file, line);

    Tcl_Obj* err;
    static if      (is(U : Tcl_Interp*))
        err = Tcl_GetObjResult(interp);
    else static if (is(U : Tcl))
        err = Tcl_GetObjResult(interp.ptr);
    int len;
    auto buf = Tcl_GetStringFromObj(err, &len);
    throw new Exception("TCL_ERROR: " ~ buf[0..len].idup ~ "\n" ~ msg,
                        file, line);
}

//------------------------------------------------------------------------------
//
// 参照カウンタ関連
//
//------------------------------------------------------------------------------
/** Call Tcl_IncrRefCount.

Throws:
Exception = when obj is null.

概要:
Tcl_Obj の参照カウンタを1増やす。
 **/
@trusted
auto reference(Tcl_Obj* obj, lazy string msg = "",
               string file = __FILE__, size_t line = __LINE__)
{
    if (obj is null) throw new Exception("null Tcl_obj* : " ~ msg, file, line);
    Tcl_IncrRefCount(obj);
    return obj;
}
/// ditto
@trusted
auto reference(Tcl_Obj*[] objs, lazy string msg = "",
               string file = __FILE__, size_t line = __LINE__)
{
    foreach (one; objs) one.reference(msg, file, line);
    return objs;
}
/** Call Tcl_DecrRefCount.

概要:
Tcl_Obj の参照カウンタを1減らす。
 **/
@trusted @nogc nothrow
void release(Tcl_Obj* obj) { if (obj !is null) Tcl_DecrRefCount(obj); }
/// ditto
@trusted @nogc nothrow
void release(Tcl_Obj*[] objs)
{ foreach (one; objs) { if (one !is null) Tcl_DecrRefCount(one); } }
/// ditto
@trusted
void release(TclCommand cmd) { if (cmd !is null) cmd.clear; }

//------------------------------------------------------------------------------
//
// Tcl_Obj* への型変換
//
//------------------------------------------------------------------------------
/** Convert D type to Tcl_Obj.

概要:
Dの型を Tcl_Obj に変換する。

詳細:
戻り値の参照カウンタは1加算されている。

Tcl_Obj* を toObj に渡した場合、戻り値は同じオブジェクトであり、参照カウンタは
増えない。
 **/
@trusted
auto toObj(int v) { return Tcl_NewIntObj(v).reference; }
@trusted
auto toObj(size_t v) { return Tcl_NewIntObj(cast(int)v).reference; }
/// ditto
@trusted
auto toObj(double v){ return Tcl_NewDoubleObj(v).reference; }
/// ditto
@trusted
Tcl_Obj* toObj(string val)
{ return Tcl_NewStringObj(val.toUTF8z, cast(int)val.length).reference; }
/// ditto
@trusted
auto toObj(wstring str)
{ return Tcl_NewUnicodeObj(str.ptr, cast(int)str.length).reference; }
/// ditto
@trusted
auto toObj(Tcl_Obj* obj){ return obj; }
/// ditto
@trusted
auto toObj(T, U)(T[U] table,  Tcl_Interp* interp = null)
{
    auto dict = Tcl_NewDictObj().reference;
    foreach (key, val; table)
        Tcl_DictObjPut(interp, dict, key.toObj, val.toObj).enOK(interp);
    return dict;
}
/// ditto
@trusted
auto toObj(T)(T[] array) if (!is(T : const(char)))
{
    auto buf = new Tcl_Obj*[array.length];
    foreach (i, one; array) buf[i] = one.toObj;
    return Tcl_NewListObj(cast(int)buf.length, buf.ptr).reference;
}

/**
概要:
スクリプトを評価済みトークンへとパースする。

詳細:
戻り値の参照カウンタは1である。
 **/
@trusted
auto toToken(string val, Tcl_Interp* interp)
{
    import std.array : Appender;

    assert(interp);
    Tcl_Parse parse;
    Tcl_ParseCommand(interp, val.ptr, cast(int)val.length, 0, &parse);
    scope(exit) Tcl_FreeParse(&parse);
    auto tok = parse.tokenPtr;
    Appender!(Tcl_Obj*[]) buf;
    buf.reserve(parse.numWords);
    for (auto i = 0; i < parse.numWords; ++i)
    {
        Tcl_EvalTokensStandard(interp, tok+1, tok.numComponents);
        auto res = Tcl_GetObjResult(interp).reference;
        buf.put(res);
        tok += tok.numComponents+1;
    }
    return buf.data;
}
/// ditto
@trusted
auto toToken(string[] vals, Tcl_Interp* interp)
{
    import std.array : Appender;
    Appender!(Tcl_Obj*[]) objs;
    objs.reserve(vals.length);
    foreach (const ref one; vals) objs.put(one.toToken(interp));
    return objs.data;
}

//------------------------------------------------------------------------------
//
// Tcl_Obj* からDへの型変換
//
//------------------------------------------------------------------------------
/**
概要:
Tcl_Obj* からDの型Tのデータを取り出す。

詳細:
Tcl_Interp を渡すとパース失敗時のメッセージを得られる。
 **/
@trusted
auto fromObj(T)(Tcl_Obj* obj, Tcl_Interp* itp = null)
{
    import std.traits : Unqual;
    assert(obj);
    T ret;
    static if      (is(T : const(char)[]))
    {
        import std.conv : to;
        int len;
        return Tcl_GetStringFromObj(obj, &len).enOK[0..len].to!T;
    }
    else static if (is(T : U[], U))
    {
        alias V = Unqual!U;
        int len;
        Tcl_Obj** objs;
        Tcl_ListObjGetElements(itp, obj, &len, &objs).enOK(itp);
        objs[0..len].reference;
        scope(exit) objs[0..len].release;
        auto result = new V[len];
        for (int i = 0; i < len; ++i)
            result[i] = objs[i].fromObj!V(itp);
        return cast(T)result;
    }
    else static if (is(T : U[V], U, V))
    {
        assert(itp);
        Tcl_DictSearch search;
        Tcl_Obj* key, val;
        int done;
        for (Tcl_DictObjFirst(itp, obj, &search, &key, &val, &done).enOK(itp);
             !done; Tcl_DictObjNext(&search, &key, &value, &done).enOK(itp))
            ret[(*key).fromObj!V(itp)] = (*val).fromObj!U;
    }
    else static if (is(T : int))
    {
        int i;
        Tcl_GetIntFromObj(itp, obj, &i);
        return cast(T)i;
    }
    else static if (is(T : double))
    {
        double d;
        Tcl_GetDoubleFromObj(itp, obj, &d);
        return cast(T)d;
    }
    else static if (is(T : Tcl_Obj*))
        return obj.reference;
    else static assert(0, "fromObj needs an implementation for " ~ T.stringof);
    return ret;
}

/** Retreave Tcl_Obj*[] from an array object of Tcl.

概要:
Tclの配列を表すTcl_Obj*からTcl_Obj*[]を取り出す。
戻り値の参照カウンタは1。
 **/
Tcl_Obj*[] toArray(Tcl_Obj* arr, Tcl_Interp* interp = null)
{
    assert(arr !is null);
    int len;
    Tcl_Obj** objs;
    Tcl_ListObjGetElements(interp, arr, &len, &objs).enOK(interp);
    return objs[0..len].reference;
}

/** Convert Tcl_Obj to string.

概要:
Tcl_Obj からDの文字列へと変換する。
 **/
alias toString = fromObj!string;
/// ditto
@trusted
string toString(Tcl_Obj*[] objs)
{
    import std.array : join;
    auto buf = new string[objs.length];
    for (size_t i = 0; i < objs.length; ++i) buf[i] = objs[i].toString;

    return ["[ \"", buf.join("\", \""), "\" ]"].join;
}

/**
 **/
auto getVar(Tcl_Interp* interp, string name)
{
    assert(interp !is null);
    return Tcl_GetVar2Ex(interp, name.toUTF8z, null, 0)
        .reference(name ~ " is not found in global scope.");
}

/**
 **/
auto getObjAt(T : int)(Tcl_Interp* interp, Tcl_Obj* arr, T idx,
                       lazy string msg = "")
{
    assert(interp !is null);
    assert(arr !is null);

    Tcl_Obj* obj;
    Tcl_ListObjIndex(interp, arr, idx, &obj).enOK(interp, msg);
    return obj.reference(msg);
}
/// ditto
auto getObjAt(T)(Tcl_Interp* interp, Tcl_Obj* dict, T key,
                 lazy string msg = "")
{
    assert(interp !is null);
    assert(dict !is null);

    auto keyObj = key.toObj;
    scope(exit) keyObj.release;
    Tcl_Obj* val;
    Tcl_DictObjGet(interp, dict, keyObj, &val).enOK(interp, msg);
    return val.reference(msg);
}

/**
 **/
int indexOf(Tcl_Obj* arr, string needle, Tcl_Interp* interp = null)
{
    auto objs = arr.toArray(interp);
    scope(exit) objs.release;
    for (int i = 0; i < objs.length; ++i)
        if (objs[i].toString == needle) return i;

    return -1;
}



/**
 **/
bool hasObjAt(T : int)(Tcl_Interp* interp, Tcl_Obj* arr, T idx)
{
    int len;
    Tcl_ListObjIndex(_interp, arr, &len).enOK;
    return idx < len;
}
///
bool hasObjAt(T)(Tcl_Interp* interp, Tcl_Obj* dict, T key)
{
    auto keyObj = key.toObj;
    scope(exit) keyObj.release;
    Tcl_Obj* val;
    Tcl_DictObjGet(interp, dict, keyObj, &val).enOK(interp);
    return val !is null;
}




/*
概要:
Tcl_Parse の中身を文字列に。デバグ用

 */
debug @trusted
string toString(in ref Tcl_Parse p)
{
    import std.array : Appender, join;
    import std.conv : to;
    Appender!(string[]) buf;
    foreach (const ref one; p.tokenPtr[0..p.numTokens])
        buf.put([one.type.to!string, one.start[0..one.size].idup,
                 one.numComponents.to!string].join(" "));
    return buf.data.join("\n");
}


//------------------------------------------------------------------------------
//
// Tclマネージャ関連
//
//------------------------------------------------------------------------------
/** A delegate that is callable from Tcl.

概要:
Tclから呼び出し可能なDのデリゲート型
**/
alias TclProc = Tcl_Obj* delegate(Tcl, Tcl_Obj*[]);

/** A delegate for Tcl.forEachInResult.

概要:
Tcl.forEachInResult の引数
**/
alias ForEachProc = void delegate(Tcl_Obj*);
/// ditto
alias ForEachProc2 = bool delegate(Tcl_Obj*);

//------------------------------------------------------------------------------
/** Express a command of Tcl.

概要:
Tclのコマンド。

詳細:
opCall()で引数を積み、最後に call()で実行する。
opCall()で積まれた引数の参照カウンタは call()実行後に1減らされるので注意。
 **/
class TclCommand
{
    private import std.array : Appender, appender;

    /**
    Params:
    bases = 評価済みトークンとして格納される。
     **/
    @trusted
    this(Tcl tcl, string bases)
    { this(tcl, bases.toToken(tcl.ptr)); }

    /**
    Params:
    bases = 評価済みトークンとして格納される。
            call()を呼び出した後も解放されず、再利用される。
     **/
    @trusted pure nothrow
    this(Tcl tcl, Tcl_Obj*[] bases = null)
    {
        _tcl = tcl;
        _commands = bases.appender;
        _baseCount = bases.length;
    }

    /**
    概要:
    全て解放する。

    詳細:
    初期化関数で渡された Tcl_Obj*[] の解放の為に必ず呼んでください。
     **/
    @trusted
    void clear()
    {
        _commands.data.release;
        _commands.clear;
        _baseCount = 0;
        _tcl = null;
    }

    /** Stack args to the parameter list.

    概要:
    引数を積む。
    **/
    auto opCall(ARGS...)(ARGS args)
    {
        foreach (one; args)
        {
            // Tcl_Obj*[]に対して toObj を呼び出すと配列を格納するTcl_Obj*へと
            // 変換してしまう為、特にそのまま積む。
            static if      (is(typeof(one) : Tcl_Obj*[]))
                _commands.put(one);
            else static if (is(typeof(one) : string))
            {
                // $で始まるトークンは変数を参照していると思われるので
                // インタプリタに処理させる。
                if (0 < one.length && one[0] == '$')
                    _commands.put(one.toToken(_tcl.ptr));
                else
                    _commands.put(one.toObj);
            }
            else
                _commands.put(one.toObj);
        }
        return this;
    }

    /** Invoke the command.

    概要:
    関数の呼び出し。

    詳細:
    関数呼び出しに使われた引数の参照カウンタを1減らす。
    **/
    Tcl call()
    {
        auto argv = _commands.data;
        _tcl.eval(argv);
        argv[_baseCount..$].release;
        _commands.shrinkTo(_baseCount);
        return _tcl;
    }

    /** Peek current parameter list.

    概要:
    現在のコマンドを見る。
    **/
    @trusted
    string peek()
    {
        import std.array : join;
        auto cmd = _commands.data;
        auto buf = new string[cmd.length];
        for (size_t i = 0; i < cmd.length; ++i) buf[i] = cmd[i].toString;
        return buf.join(" ");
    }

    ///
    auto toObj(){ return call.toObj; }

    /**
    概要:
    コマンド型を変換する。

    詳細:
    自身はクリアされるので注意。
    **/
    auto to(T : TclCommand)()
    {
        auto ret = new T(_tcl, _commands.data);
        _commands.clear;
        _baseCount = 0;
        _tcl = null;
        return ret;
    }

    /**
    概要:
    複製する。

    詳細:
    Tcl_Obj*参照の参照カウンタを増加させるので注意。
     **/
    TclCommand dup() { return _dup!TclCommand; }

    /**
    概要:
    コマンド先頭の Tcl_Obj* を返す。

    詳細:
    戻り値の参照カウンタは1増えているので注意。
     **/
    @property @trusted
    Tcl_Obj* reference()
    {
        assert (0 < _commands.data.length);
        return _commands.data[0].reference;
    }

    /**
    概要:
    コマンド先頭の Tcl_Obj* を返す。

    詳細:
    戻り値の参照カウンタは増えない。
     **/
    @property @trusted
    Tcl_Obj* ptr()
    {
        assert (0 < _commands.data.length);
        return _commands.data[0];
    }

protected:
    /*

    概要:
    コマンドが実行されるべき Tclクラス。
    */
    @property @trusted @nogc pure nothrow
    Tcl tcl(){ return _tcl; }

    /*
    概要:
    dup関数の中身
    */
    auto _dup(T)() if (is(T : TclCommand))
    {
        auto data = _commands.data;
        auto ret = new T(_tcl, data[0.._baseCount].reference);
        ret.opCall(data[_baseCount .. $ ].reference);
        return ret;
    }


    auto data(){ return _commands.data.reference; }
private:
    Appender!(Tcl_Obj*[]) _commands; //
    size_t _baseCount; // _ccmmandsのここまでは再利用しますよフラグ
    Tcl _tcl; //
    static size_t _delCount;
}

//------------------------------------------------------------------------------
//
/*
PARAMSの先頭をD言語の変数名として好ましい文字列へと変換する。
*/
private template goodName(PARAMS...) if (0 < PARAMS.length)
{
    template Impl(string PARAM) if (0 < PARAM.length)
    {
        private import std.algorithm : find, count;
        private import std.range : retro, empty;

        template good(string N)
        { enum good = __traits(compiles, mixin("{int " ~ N ~ ";}")); }

        static if      (3 < PARAM.length && PARAM[0..3] == "tk_")
            enum Impl = Impl!(PARAM[3..$]);
        else static if (4 < PARAM.length && PARAM[0..4] == "pkg_")
            enum Impl = Impl!(PARAM[4..$]);
        else static if (good!PARAM)
            enum Impl = PARAM;
        else static if (good!("_" ~ PARAM))
            enum Impl = "_" ~ PARAM;
        else static if (PARAM[0] == '-')
            enum Impl = Impl!(PARAM[1..$]);
        else static if (!PARAM.find(':').empty)
            enum Impl = Impl!(PARAM[PARAM.retro.find(':').count..$]);
        else static assert(0, PARAM ~ " is not a good name.");
    }

    static if      (is(typeof(PARAMS[0]) : string))
        enum goodName = Impl!(PARAMS[0]);
    else static if (is(typeof(PARAMS[0]) : string[]) && 0 < PARAMS[0].length)
        enum goodName = Impl!(PARAMS[0][0]);
    else static if (is(PARAMS[0] : TclCommandEx!(BASE, A), string BASE, A...))
        enum goodName = Impl!BASE;
    else static if (is(PARAMS[0] : TclCommandGroup!(BASE, A),
                       string BASE, A...))
        enum goodName = Impl!BASE;
    else static assert(0, PARAMS[0].stringof ~ " is not a good name.");
}
/*
PARAMSの先頭をTclのコマンドへと変換する。
*/
private template Params(PARAMS...) if (0 < PARAMS.length)
{
    static if      (is(typeof(PARAMS[0]) : string))
        enum Params = [PARAMS[0]];
    else static if (is(typeof(PARAMS[0]) : string[]) && 1 < PARAMS[0].length)
        enum Params = PARAMS[0][1..$];
    else static if (is(PARAMS[0] : TclCommandEx!(BASE, A), string BASE, A...))
        enum Params = [BASE];
    else static if (is(PARAMS[0] : TclCommandGroup!(BASE, A),
                       string BASE, A...))
        enum Params = [BASE];
    else static assert(0, PARAMS[0].stringof ~ " is not a good command.");
}

/*
参照名はコマンドから自動的に生成される。
明示したい場合は、文字列の配列を使い、
["referenceName", "actual", "commands",..."], ...
の用にする。配列[0] が参照される名前に、それより後が実際のコマンドとなる。
Params:
COMMANDS = "コマンド",...
 */
private
mixin template TTclCommandGroup(COMMANDS...)
{
    /*
    コマンドの中身を格納する変数を宣言する。
     */
    private mixin template _decls(REST...)
    {
        static if (0 < REST.length)
        {
            static if      (is(REST[0] T))
                mixin("T " ~ goodName!REST ~ "Impl;");
            else static if (is(typeof(REST[0]) : string) ||
                            is(typeof(REST[0]) : string[]))
                mixin("TclCommand " ~ goodName!REST ~ "Impl;");
            else static assert(0);
            mixin _decls!(REST[1..$]);
        }
    }
    mixin _decls!COMMANDS;

    /*
    呼び出されるメンバ関数を定義する。
    初回呼び出し時に実体を格納する変数が初期化される。
     */
    private mixin template _defs(REST...)
    {
        static if (0 < REST.length)
        {
            import std.array : stdjoin = join;
            static import std.array;
            alias NAME = goodName!REST;
            enum P = Params!REST;
            static if      (is(REST[0] T))
                alias Type = T;
            else static if (is(typeof(REST[0]) : string) ||
                            is(typeof(REST[0]) : string[]))
                alias Type = TclCommand;
            else static assert(0);

            mixin(["auto ", NAME, "(ARGS...)(ARGS args){",
                   "if (", NAME, "Impl is null)",
                   NAME, "Impl = new Type(tcl, tcl.cache(P));",
                   "return ", NAME, "Impl.opCall(args);}"].stdjoin);
            mixin _defs!(REST[1..$]);
        }
    }
    mixin _defs!COMMANDS;

    //
    private
    void clear()
    {
        void _clear(REST...)()
        {
            static if (0 < REST.length)
            {
                enum Name = goodName!REST ~ "Impl";
                if (auto p = __traits(getMember, this, Name))
                    p.clear;
                __traits(getMember, this, Name) = null;
                _clear!(REST[1..$]);
            }
        }
        _clear!COMMANDS;
    }
}

/** Define a long name.

概要:
"ttk" など、名前空間的なもの。
 **/
class TclCommandGroup(string BASE, COMMAND...)
{
    mixin TTclCommandGroup!COMMAND Group;

    //
    this(Tcl tcl, string) { this.tcl = tcl; }
    //
    this(Tcl tcl, Tcl_Obj*[]) { this.tcl = tcl; }

    ///
    auto opCall(ARGS...)(ARGS){ return this; }

    ///
    void clear(){ Group.clear; }
private:
    Tcl tcl; // TTclCommandGroup から参照される。
}

//------------------------------------------------------------------------------
/**
概要:
コマンドと引数の組み合わせを定義する。

詳細:
D言語からの参照名は BASE より自動生成される。
PARAMSには、コマンドに対して使える引数が指定される。
"-command" に対するD言語からの参照名は command
"-auto"            〃                  _auto
などのように変形される。
**/
class TclCommandEx(string BASE, PARAMS...) : TclCommand
{
    ///
    this(Tcl tcl, string base) { super(tcl, base); }

    ///
    this(Tcl tcl, Tcl_Obj*[] bases = null) { super(tcl, bases); }

    //
    override
    void clear()
    {
        void _clear(PARAM...)()
        {
            static if (0 < PARAM.length)
            {
                __traits(getMember, this, goodName!PARAM ~ "Obj").release;
                _clear!(PARAM[1..$]);
            }
        }
        _clear!PARAMS;
        super.clear;
    }

    //
    auto opCall(ARGS...)(ARGS args){ super.opCall(args); return this; }

    //
    override
    TclCommandEx dup() { return _dup!TclCommandEx(); }

    /*
    概要:
    キャッシュ済みの引数を引数スタックに積む。

    詳細:
    初回呼び出し時にキャッシュされる。
    */
    private mixin template _defs(PARAM...)
    {
        static if (0 < PARAM.length)
        {
            import std.array : stdjoin = join;
            alias NAME = goodName!PARAM;
            enum P = Params!PARAM;

            static if      (is(PARAM[0] T : TclCommandEx!(B, A),
                               string B, A...))
                mixin(["auto ", NAME, "(ARGS...)(ARGS args){",
                       "if (", NAME, "Obj is null)", NAME,
                       "Obj = new T(tcl, data ~ B.toToken(tcl.ptr));"
                       "return ", NAME, "Obj.opCall(args); }"].stdjoin);
            else static if (is(typeof(PARAM[0]) : string) ||
                            is(typeof(PARAM[0]) : string[]))
                mixin(["auto ", NAME, "(ARGS...)(ARGS args){",
                       "if (", NAME, "Obj is null)", NAME,
                       "Obj = tcl.cache(P);", "return opCall(", NAME,
                       "Obj.reference, args); }"].stdjoin);
            else
                static assert(0);

            mixin _defs!(PARAM[1..$]);
        }
    }
    mixin _defs!PARAMS;

private:
    /*
    概要:
    コマンドの引数の評価済みトークンを格納する。
    */
    private mixin template _decls(PARAM...)
    {
        static if (0 < PARAM.length)
        {
            import std.array : stdjoin = join;
            enum NAME = goodName!PARAM;
            static if      (is(PARAM[0] T))
                mixin(["T ", NAME, "Obj;"].stdjoin);
            else static if (is(typeof(PARAM[0]) : string) ||
                            is(typeof(PARAM[0]) : string[]))
                mixin(["Tcl_Obj*[] ", NAME, "Obj;"].stdjoin);
            else static assert(0, NAME ~  ":" ~ PARAM[0].stringof);
            mixin _decls!(PARAM[1..$]);
        }
    }
    mixin _decls!PARAMS;
}

//------------------------------------------------------------------------------
/**
概要:
1回使い捨て用コマンド。

詳細:
opDispatch によりなんでも積む。
opDispatch を通した物はキャッシュされる。
**/
class TclCommandTmp : TclCommand
{
    ///
    this(Tcl tcl, Tcl_Obj*[] base...) { super(tcl, base); }

    ///
    auto opDispatch(string _CMD, ARGS...)(ARGS args)
    {
        static if (0 < _CMD.length && _CMD[0] == '_')
            enum CMD = "-" ~ _CMD[1..$];
        else
            enum CMD = _CMD;

        opCall(tcl.cache(CMD), args);
        return this;
    }

    ///
    override
    Tcl call()
    {
        super.call();
        auto t = tcl;
        clear;
        return t;
    }

    ///
    override
    TclCommandTmp dup() { return _dup!TclCommandTmp(); }

    ///
    void logcall() { .logcall(this); }
}
//------------------------------------------------------------------------------
/** A wrapper of Tcl_Interp.

概要:
Tcl_Interp のラッパ
 **/
class Tcl
{
    import std.traits : isSomeFunction;

    mixin TTclCommandGroup!(
        TclCommandEx!(
            "after",
            "cancel", "idle", "info"),
        // "append", "append",
        // "apply", "apply",
        // "array", TclCommandEx!(
        //     "array",
        //     "anymore", "donesearch", "exists", "get", "names", "nextelement",
        //     "set", "size", "startsearch", "statistics", "unset"),

        // "execok", "auto_execok",
        // "auto_import", "auto_import",
        // "load", "auto_load",
        // "mkindex", "auto_mkindex",
        // "reset", "auto_reset",
        // "qualify", "auto_qualify",
        // "findLIbrary", "tcl_findLibrary",
        // "parray", "parray",
        // "endOfWord", "tcl_endOfWord",
        // "startOfNextWord", "tcl_startOfNextWord",
        // "startOfPreviousWord", "tcl_startOfPreviousWord",
        // "wordBreakAfter", "tcl_wordBreakAfter",
        // "wordBreakBefore", "tcl_wordBreakBefore",

        // "bgerror", "bgerror",

        // "binary", TclCommandEx!(
        //     "binary",
        //     "format", "scan"),

        // "break", "break",
        "catch",
        "cd",
        TclCommandEx!(
            "chan",
            "blocked",
            "close",
            TclCommandEx!(
                "configure",
                "-blocking", "-buffering", "-buffersize", "-encoding",
                "-eofchar", "-translation"),
            TclCommandEx!(
                "copy",
                "-size", "-command"),
            "create",
            "eof",
            "event",
            "flush",
            "gets",
            "names",
            "pending",
            "postevent",
            TclCommandEx!(
                "puts",
                "-nonewline"),
            "read",
            TclCommandEx!(
                "read",
                "-nonewline"),
            TclCommandEx!(
                "seek",
                "start", "current", "end"),
            "tell",
            "truncate"),
        TclCommandEx!(
            "clock",
            "add", "clicks", "format", "microseconds", "milliseconds", "scan",
            "seconds",
            "-base", "-format", "-gmt", "locale", "timezone"),
        "close",
        // "concat", "concat",
        // "continue", "continue",

        TclCommandEx!(
            "dde",
            TclCommandEx!(
                "servername",
                "-force", "-handler"),
            TclCommandEx!(
                "execute",
                "-async"),
            "poke",
            TclCommandEx!(
                "request",
                "-binary"),
            "service",
            TclCommandEx!(
                "eval",
                "-async"),
            "servername", "execute", "poke", "request", "services", "eval",
            "-force", "-handler", "-async", "-binary", "-async"),
        // "dict", TclCommandEx!(
        //     "dict",
        //     "append", "create", "exists", "filter", "_for", "get", "incr",
        //     "info", "keys", "lappend", "merge", "remove", "replace", "set",
        //     "size", "unset", "update", "values", "_with", "key", "script",
        //     "value"),
        TclCommandEx!(
            "encoding",
            "convertfrom", "convertto", "dirs", "names", "system"),
        "eof",
        "error",
        // "eval", "eval",
        TclCommandEx!(
            "exec",
            "-ignorestderr", "-keepnewline"),
        "exit",
        // "expr", "expr",
        "fblocked",
        TclCommandEx!(
            "fconfigure",
            "-blocking", "-buffering", "-buffersize", "-encoding", "-encoding",
            "-eofchar", "-translation",
            "_auto", "binary", "cr", "crlf", "lf",),
        TclCommandEx!(
            "fcopy",
            "-size", "-command"),
        TclCommandEx!(
            "file",
            "atime", "attributes", "channels", "copy", ["_delete", "delete"],
            "dirname", "executable", "exists", "extension", "isdirectory",
            "isfile", "join", "link", "lstat", "mkdir", "mtime", "nativename",
            "normalize", "owned", "pathtype", "readable", "readlink", "rename",
            "rootname", "separator", "size", "split", "stat", "system", "tail",
            "type", "volumes", "writable",
            "-force"
            ),
        TclCommandEx!(
            "fileevent",
            "readable", "writable"),
        "filename",
        "flush",
        // "_for", "for",
        // "_foreach", "foreach",
        "format",
        "gets",
        TclCommandEx!(
            "glob",
            "-directory", "-join", "-nocomplain", "-path", "-tails", "-types"),
        // "global", "global",
        TclCommandEx!(
            "history",
            "add", "change", ["_clear", "clear"], "event", "info", "keep",
            "nextid", "redo"),
        TclCommandGroup!(
            "http",
            TclCommandEx!(
                "::http::config",
                "-accept", "-proxyhost", "-proxyport", "-proxyfilter",
                "-urlencoding", "-useragent"),
            TclCommandEx!(
                "::http::geturl",
                "-binary", "-blocksize", "-channel", "-command", "-handler",
                "-headers", "-keepalive", "-method", "-myaddr", "-progress",
                "-protocol", "-query", "-queryblocksize", "-querycyannel",
                "-queryprogress", "-strict", "-timeout", "-type", "validate"),
            "::http::formatQuery",
            "::http::reset",
            "::http::reset",
            "::http::data",
            "::http::error",
            "::http::status",
            "::http::code",
            "::http::ncode",
            "::http::size",
            "::http::meta",
            "::http::cleanup",
            "::http::register",
            "::http::unregister"),

        // "if", "if",
        "incr",
        TclCommandEx!(
            "info",
            "args", "body", "cmdcount", "commands", "complete",
            "default", "exists", "frame", "functions", "globals",
            "hostname", "level", "library", "loaded", "locals",
            "nameofexecutale", "patchlevel", "procs", "script",
            "sharedlibextension", "tclverson", "vars"),
        TclCommandEx!(
            "interp",
            "alias", "aliases", "bgerror", "create",
            "debug", "delete", "eval", "exists",
            "expose", "hide", "hidden", "invokehidden", "limit", "issafe",
            "marktrusted", "recursionlimit", "share", "slaves", "target",
            "transfer",
            "-safe", "-command", "-granularity", "-milliseconds", "-seconds",
            "-value"),

        // "join", "join",
        // "lappend", "lappend",
        // "lassign", "lassign",
        // "lindex", "lindex",
        // "linsert", "linsert",
        // "list", "list",
        // "llength", "llength",
        "load", "load",
        // "lrange", "lrange",
        // "lrepeat", "lrepeat",
        // "lreplace", "lreplace",
        // "lreverse", "lreverse",
        // "lsearch", TclCommandEx!(
        //     "lsearch",
        //     "-exact", "-glob", "-regexp", "-sorted", "-all", "-inline",
        //     "-not", "-start", "-ascii", "-dictionary", "-integer",
        //     "-nocase", "-real", "-decreasing", "-increasing", "-index",
        //     "-subindices"),
        // "lset", "lset",
        // "lsort", TclCommandEx!(
        //     "lsort",
        //     "-ascii", "-dictionary", "-integer", "-real", "-command",
        //     "-increasing", "-decreasing", "-indices", "-index", "-nocase",
        //     "-unique"),

        // "abs", "::tcl::mathfunc::abs",
        // "acos", "::tcl::mathfunc::acos",
        // "asin", "::tcl::mathfunc::asin",
        // "atan", "::tcl::mathfunc::atan",
        // "atan2", "::tcl::mathfunc::atan2",
        // "_bool", "::tcl::mathfunc::bool",
        // "ceil", "::tcl::mathfunc::ceil",
        // "cos", "::tcl::mathfunc::cos",
        // "cosh", "::tcl::mathfunc::cosh",
        // "_double", "::tcl::mathfunc::double",
        // "entier", "::tcl::mathfunc::entier",
        // "exp", "::tcl::mathfunc::exp",
        // "floor", "::tcl::mathfunc::floor",
        // "fmod", "::tcl::mathfunc::fmod",
        // "hypot", "::tcl::mathfunc::hypot",
        // "_int", "::tcl::mathfunc::int",
        // "isqrt", "::tcl::mathfunc::isqrt",
        // "log", "::tcl::mathfunc::log",
        // "log10", "::tcl::mathfunc::log10",
        // "max", "::tcl::mathfunc::max",
        // "min", "::tcl::mathfunc::min",
        // "pow", "::tcl::mathfunc::pow",
        // "rand", "::tcl::mathfunc::rand",
        // "round", "::tcl::mathfunc::round",
        // "sin", "::tcl::mathfunc::sin",
        // "sinh", "::tcl::mathfunc::sinh",
        // "sqrt", "::tcl::mathfunc::sqrt",
        // "srand", "::tcl::mathfunc::srand",
        // "tan", "::tcl::mathfunc::tan",
        // "tanh", "::tcl::mathfunc::tanh",
        // "wide", "::tcl::mathfunc::wide",

        TclCommandEx!(
            "memory",
            "active", "break_on_malloc", "info", "init", "objs", "onexit",
            "tag", "trace", "racne_on_at_malloc", "validate"),

        TclCommandGroup!(
            "msgcat",
            "::msgcat::mc",
            "::msgcat::mcmax",
            "::msgcat::mclocale",
            "::msgcat::mcpreferences",
            "::msgcat::mcload",
            "::msgcat::mcset",
            "::msgcat::mcmset",
            "::msgcat::mcflset",
            "::msgcat::mcflmset",
            "::msgcat::mcunknown"),

        // TclCommandEx!(
        //     "namespace",
        //     "children", "code", "current", "delete", "ensemble", "eval",
        //     "exists", "export", "forget", "import", "inscope", "origin",
        //     "parent", "path", "qualifiers", "tail", "upvar", "unknown",
        //     "which",
        //     "create", "configure", "exists",
        //     "-clear", "-force", "-command", "-variable",
        //     "-map", "-prefixes", "-subcommands", "-unknown", "-namespace"),

        TclCommandEx!(
            "open",
            "-mode", "-handshake", "-queue", "-timeout", "-ttycontrol",
            "-ttystatus", "-xchar", "-pollinterval", "-sysbuffer",
            "-lasterror"),

        TclCommandEx!(
            "package",
            "forget", "ifneeded", "names", "present", "provide", "require",
            "unknown", "vcompare", "versions", "vsatisfies", "prefer",
            ["latest", "prefer", "latest"],
            ["stable", "prefer", "stable"],
            "-exact"),
        // "pid",

        // TclCommandGroup!(
        //     "pkg",
        //     TclCommandEx!(
        //         "pkg::create",
        //         "-name", "-version", "-load", "-source"),
        //     TclCommandEx!(
        //         "pkg_mkIndex",
        //         "-direct", "-lazy", "-load", "-verbose"),
        //     ),

        TclCommandGroup!(
            "platform",
            "platform::generic",
            "platform::identify",
            "platform::patterns",
            TclCommandGroup!(
                "shell",
                "platform::shell::generic",
                "platform::shell::identify",
                "platform::shell::platform"),
            ),
        "proc",
        "puts",
        "pwd",
        "read",
        TclCommandEx!(
            "regexp",
            "-about", "-expanded", "-indices", "-line", "-linestop",
            "-lineanchor", "-nocase", "-all", "-inline", "-start"),
        TclCommandEx!(
            "registry",
            "broadcast", "delete", "get", "keys", "set", "type", "values",
            "binary", "none", "sz", "expand_sz", "dword", "dword_big_endian",
            "link", "multi_sz", "resource_list",
            "-timeout"),
        TclCommandEx!(
            "regsub",
            "-all", "-expanded", "-line", "-linestop", "-lineanchor", "-nocase",
            "-start"),
        "rename",

        // TclCommandEx!(
        //     "return",
        //     "-errorcode", "-errorinfo", "-level", "-options"),

        // TclCommandGroup!(
        //     "safe",
        //     "::safe::interpCreate",
        //     "::safe::interpInit",
        //     "::safe::interpConfigure",
        //     "::safe::interpDelete",
        //     "::safe::interpFindInAccessPath",
        //     "::safe::interpAddToAccessPath",
        //     "::safe::setLogCmd"),

        "scan",
        "seek",
        // "set",

        TclCommandEx!(
            "socket",
            "-myaddr", "-myport", "-async", "-error", "-sockname", "-peername"),
        TclCommandEx!(
            "source",
            "-encoding"),
        // "split",
        // TclCommandEx!(
        //     "string",
        //     "compare", "equal", "first", "index", "is", "alnum", "alpha",
        //     "ascii", "boolean", "control", "digit", "double", "false",
        //     "graph", "integer", "list", "lower", "print", "punct", "space",
        //     "true", "upper", "wideinteger", "wordchar", "xdigit", "last",
        //     "length", "map", "match", "range", "repeat", "replace",
        //     "reverse", "tolower", "totitle", "toupper", "trim", "trimleft",
        //     "trimright", "bytelength", "wordend", "wordstart"),

        // "subst",
        // "switch",

        // TclCommandGroup!(
        //     "::tcltest::test",
        //     "::tcltest::loadTestedCommands",
        //     "::tcltest::makeFile",
        //     "::tcltest::removeFile",
        //     "::tcltest::makeDirectory",
        //     "::tcltest::removeDirectory",
        //     "::tcltest::viewFile",
        //     "::tcltest::cleanupTest",
        //     "::tcltest::runAllTests",
        //     "::tcltest::configure",
        //     "::tcltest::customMatch",
        //     "::tcltest::testConstraint",
        //     "::tcltest::interpreter",
        //     "::tcltest::outputChannel",
        //     "::tcltest::errorChannel"),

        "env",

        "tell",
        "time",
        TclCommandGroup!(
            "tm",
            TclCommandEx!(
                "::tcl::tm::path",
                "add", "remove", "list"),
            "::tcl::tm::roots"),

        TclCommandEx!(
            "trace",
            "add", "rename", "delete", "execution", "enter", "leave",
            "enterstep", "leavestep", "variable", "array", "read", "write",
            "unset", "remove", "command", "execution", "info", "vdelete",
            "vinfo"),
        "unknown",
        "unload",
        // "unset",
        "update",
        "uplevel",
        "upvar",
        "variable",
        "vwait",
        // "while",
        ) Group;

    ///
    this(Tcl_Interp* i)
    {
        _interp = i;
        _status = TCL_OK;
    }

    /**
    概要:
    キャッシュを解放する。installされた関数は解放しない。

    詳細:
    Tkの初期スクリプト終了後に呼び出しておくと省リソース。
     **/
    void clearCache()
    {
        Group.clear;
        foreach (one; _cache)
            one.release;
        _cache = null;
    }

    /** Clear Tcl

    Tcl_Interp isn't cleared.

    概要:
    Tcl_interp の解放はしない。
    **/
    void clear()
    {
        clearCache;
        foreach (c; _userCommand)
            Tcl_DeleteCommandFromToken(_interp, c);
        _userCommand = null;
    }

    /**
    概要:
    ナカミ
     **/
    @property @trusted @nogc pure nothrow
    Tcl_Interp* ptr(){ return _interp; }

    /**
    概要:
    現在のコマンドの終了状態。
     **/
    @property @trusted @nogc pure nothrow
    int status() const { return _status; }


    /** Evaluate the script.

    概要:
    スクリプトを実行する。
     **/
    Tcl eval(string script)
    {
        _status = Tcl_EvalEx(_interp, script.ptr, cast(int)script.length,
                             TCL_EVAL_GLOBAL).enOK(_interp);
        return this;
    }
    /// ditto
    Tcl eval(Tcl_Obj*[] objs...)
    {
        _status = Tcl_EvalObjv(_interp, cast(int)objs.length, objs.ptr,
                               TCL_GLOBAL_ONLY).enOK(_interp);
        return this;
    }

    ///
    auto toObj() { return Tcl_GetObjResult(_interp).reference("result"); }

    /**
    概要:
    Tcl内の変数への参照を特に格納する。

    詳細:
    opIndex の戻り値として利用される。
    **/
    struct TclVariableReference
    {
        /**
        概要:
        D言語の型へと変換する。

        詳細:
        実行後、Tcl_Objの参照カウンタを1減ずる。
         **/
        auto to(T)()
        {
            scope(exit) _payload.release;
            return _payload.fromObj!T(_tcl.ptr);
        }
        /**
        概要:
        コマンドとして取り出す。
         **/
        auto to(T : TclCommand)() { return new T(_tcl, [_payload]); }

        /**
        概要:
        一時コマンドを開始する。
         **/
        auto opDispatch(string CMD, ARGS...)(ARGS args)
        {
            auto cmd = new TclCommandTmp(_tcl, _payload);
            return cmd.opDispatch!CMD(args);
        }

        /**
        概要:
        中身を返す。
         **/
        @property @trusted @nogc pure nothrow
        auto toObj() { return _payload; }
        alias ptr = toObj;

        /**
        概要:
        配列とみなして要素にアクセスする。
         **/
        auto opIndex(U : int)(U idx)
        {
            import std.conv : to;
            return getObjAt(_tcl.ptr, _payload, idx,
                            _name ~ "[" ~ idx.to!string ~ "]");
        }

        /**
        概要:
        連想配列とみなして要素にアクセスする。
        **/
        auto opIndex(U)(U key)
        {
            import std.conv : to;
            return getObjAt(_tcl.ptr, _payload, key,
                            _name ~ "[" ~ key.to!string ~ "]");
        }

        /**
        概要:
        連想配列とみなして、key が存在するかどうかを調べる。
         **/
        bool opBinaryRight(string OP : "in", T)(T key)
        { return hasObjAt(_tcl.ptr, _payload, key); }

        /** Traverse objects in the obj.

        概要:
        配列とみなして要素を巡回する。
         **/
        auto forEach(ForEachProc proc)
        {
            auto objs = _payload.toArray;
            scope(exit) objs.release;
            foreach (one; objs) proc(one);
            return this;
        }
        /// ditto
        auto forEach(ForEachProc2 proc)
        {
            auto objs = _payload.toArray;
            scope(exit) objs.release;
            foreach (one; objs) if (!proc(one)) break;
            return this;
        }

        ///
        void release(){ _payload.release; }

        ///
        auto dup()
        { return TclVariableReference(_tcl, _name, _payload.reference); }

    private:
        Tcl _tcl;
        string _name;
        Tcl_Obj* _payload; // refCount 1で初期化されるべき。

        @trusted @nogc pure nothrow
        this(Tcl tcl, string name, Tcl_Obj* obj)
        {
            _tcl = tcl;
            _name = name;
            assert(0 < obj.refCount);
            _payload = obj;
        }
        @trusted
        this(Tcl tcl, string name) { this(tcl, name, tcl.ptr.getVar(name)); }
        @trusted @nogc pure nothrow
        this(Tcl tcl, Tcl_Obj* obj) { this(tcl, "anonymous", obj); }
    }

    /**
    概要:
    現在のコマンドの結果を、参照カウンタを1増やして返す。
    **/
    auto result() { return TclVariableReference(this, toObj); }

    /**
    概要:
    初期引数 cmd で一時コマンドを開始する。

    詳細:
    戻り値は参照カウンタを増やしているので必ずcallすべき。
     **/
    auto opCall(string cmd) { return new TclCommandTmp(this, cache(cmd)); }
    /// ditto
    auto opCall(Tcl_Obj* cmd) { return new TclCommandTmp(this, cmd); }

    /** Define a function in the global scope of Tcl.

    概要:
    Tclのグローバルスコープに関数を定義する。
     **/
    void install(PROC)(string name, PROC proc) if (isSomeFunction!PROC)
    {
        alias TP = TProc!PROC;
        uninstall(name);

        auto data = mallocInstance!(TP.MyData)(this, name, proc);
        _userCommand[name] = Tcl_CreateObjCommand(
            _interp, name.toUTF8z, &TP.cmdProc, data, &TP.freeProc);
    }
    /// ditto
    void uninstall(string name)
    {
        if (auto pc = name in _userCommand)
        {
            Tcl_DeleteCommandFromToken(_interp, (*pc));
            _userCommand.remove(name);
        }
    }

    /**
    概要:
    無名デリゲートに、モジュール名+行数で名前を与えて Tcl のグローバルスコープに
    登録し、callerで引数を与えて呼び出すスクリプト文字列が格納されたTcl_Obj*を
    返す。

    バグ:
    同一行には1つしか書けないので注意。
     **/
    Tcl_Obj* lambda(string mod = __MODULE__, size_t line = __LINE__, PROC)
        (PROC proc, string caller = "") if (isSomeFunction!PROC)
    {
        import std.conv : to;
        import std.array : join;
        import std.algorithm : filter;
        enum delName = ["lambda_", mod.filter!"a != '.'".to!string,
                         "_at_", line.to!string].join;
        if (delName !in _userCommand)
            install(delName, proc);
        return [delName, caller].join(" ").toObj;
    }


    /** Get the value of the variable of Tcl.

    概要:
    Tcl内の変数の値を得る。
     **/
    auto opIndex(string varName)
    { return TclVariableReference(this, varName); }

    /**
    概要:
    Tcl内の変数 varName を配列とみなして要素にアクセスする。
     **/
    auto opIndex(U : int)(string varName, U idx)
    {
        auto arr = opIndex(varName);
        scope(exit) arr.release;
        return arr[idx];
    }

    /**
    概要:
    Tcl内の変数 varName を連想配列とみなして要素にアクセスする。
     **/
    auto opIndex(U)(string varName, U key)
    {
        auto dict = opIndex(varName);
        scope(exit) dict.release;
        return dict[key];
    }


    /** Set the value to the variable of Tcl.

    概要:
    Tcl内の変数に値を設定する。
     **/
    auto opIndexAssign(T)(T val, string name)
    {
        static if (is(T : Tcl_Obj*))
            auto valObj = val.reference;
        else
            auto valObj = val.toObj;

        Tcl_Obj*[]* target;
        if (auto p = name in _cache) target = p;
        else { _cache[name] = [name.toObj, null]; target = name in _cache; }

        assert(target !is null);
        if (1 < (*target).length) (*target)[1..$].release;
        (*target).length = 2;

        auto nameObj = (*target)[0].reference;
        auto retObj = Tcl_ObjSetVar2(_interp, nameObj, null, valObj, 0)
            .reference;

        valObj.release;
        (*target)[1] = retObj;

        return retObj;
    }

    /**
    概要:
    Tclによる文字列の置換を行う。
     **/
    Tcl_Obj* subst(string str)
    {
        auto obj = Tcl_NewStringObj(str.toUTF8z, cast(int)str.length);
        return Tcl_SubstObj(_interp, obj, TCL_SUBST_ALL).reference;
    }

    /**
    概要:
    src をスクリプトとして評価済みトークンへと変換し、内部キャッシュに保存する。
     **/
    Tcl_Obj*[] cache(string src)
    {
        Tcl_Obj*[] objs;
        if (auto p = src in _cache) objs = (*p);
        else
        {
            objs = src.toToken(_interp);
            _cache[src] = objs;
        }
        return objs.reference;
    }
    /// ditto
    Tcl_Obj*[] cache(string[] srcs)
    {
        import std.array : Appender;
        Appender!(Tcl_Obj*[]) buf;
        buf.reserve(srcs.length);
        foreach (one; srcs) buf.put(cache(one));
        return buf.data;
    }

    /**
     **/
    Tcl_Obj* mc(ARGS...)(ARGS msg) { return msgcat.mc(msg).call.toObj; }
    /**
     **/
    string mcString(ARGS...)(ARGS msg)
    {
        auto obj = mc(msg);
        scope(exit) obj.release;
        return obj.toString;
    }

    /**
     **/
    void require(string pkg, string ver = null)
    {
        auto ppkg = pkg.toUTF8z;
        auto pver = ver ? ver.toUTF8z : null;
        Tcl_PkgRequire(_interp, ppkg, pver, 0)
            .enOK(_interp, "Required " ~ pkg ~ " version " ~ ver ~
                  " is not satisfied.");
    }

private:
    Tcl_Interp* _interp; // ナカミ
    int _status; // 現在のコマンドの終了状態

    Tcl_Obj*[][string] _cache; // 評価済みトークンのキャッシュ
    Tcl_Command[string] _userCommand; // install により格納された関数。

    // TTclCommandGroup より参照される。
    @property @trusted @nogc pure nothrow
    Tcl tcl(){ return this; }

    // Tcl から D言語の関数を呼び出す。
    template TProc(PROC) if (isSomeFunction!PROC)
    {
        import std.traits : ParameterTypeTuple, ReturnType;
        alias PARAMS = ParameterTypeTuple!PROC;
        alias RETURN = ReturnType!PROC;

        // ClientData として Tcl に渡される。
        struct MyData
        {
            Tcl tcl;
            string name;
            PROC proc;
        }

        // Tcl から直に呼ばれる関数本体
        extern(C) static nothrow
        int cmdProc(void* clientData, Tcl_Interp* interp, int objc,
                    Tcl_Obj** objv)
        {
            auto data = cast(MyData*)clientData;
            try
            {
                PARAMS params;
                size_t c;

                // 引数の型変換を行う。
                foreach (ref one; params)
                {
                    static if (is(typeof(one) : Tcl))
                        one = data.tcl;
                    else if   (c+1 < objc)
                        one = objv[++c].fromObj!(typeof(one));
                    else
                        one = typeof(one).init;
                }

                // 呼び出す。
                static if (is(RETURN == void))
                    data.proc(params);
                else
                {
                    auto res = data.proc(params).toObj;
                    Tcl_SetObjResult(interp, res);
                    res.release;
                }
            }
            catch (Throwable t)
            {
                string msg;
                try msg = t.toString; catch (Throwable){}
                Tcl_AddObjErrorInfo(interp, msg.ptr, cast(int)msg.length);
                return TCL_ERROR;
            }
            return TCL_OK;
        }

        // Tcl から解放時に呼ばれる。
        extern(C) static nothrow
        void freeProc(void* data) { freeInstance(cast(MyData*)data);}
    }
}


//------------------------------------------------------------------------------
/**
概要:
Tclにコマンドを追加する際に使う。

詳細:
実装に関しては、$(LINK #dtk.util) を参照。
 **/
class TclEx(COMMANDS...) : Tcl
{
    mixin TTclCommandGroup!(COMMANDS) GroupEx;

    ///
    this(Tcl_Interp* i) { super(i); }

    ///
    override
    void clear()
    {
        GroupEx.clear;
        super.clear;
    }
}

/** enforce Tcl version.

Params:
ma = major version.
mi = minor version.
 **/
void requireTcl(int ma, int mi)
{
    import std.conv : to;
    int maR, miR, patchR, type;
    Tcl_GetVersion(&maR, &miR, &patchR, &type);
    enOK(ma < maR || (ma == maR && mi <= miR), null,
         "Required Tcl version is " ~ ma.to!string ~ "." ~ mi.to!string ~
         ", but loaded version is " ~ maR.to!string ~ "." ~ miR.to!string ~
         ".");
}

//------------------------------------------------------------------------------
//
class LoggerTcl(T) : T if (is(T : Tcl))
{
    this(Tcl t){ super(t.ptr); }

    override
    void clear(){ super.clear; _buf.clear; }

    override
    LoggerTcl eval(string script) { _buf.put(script); return this; }

    override
    LoggerTcl eval(Tcl_Obj*[] objs...)
    {
        import std.algorithm : find;
        import std.array : empty, join;
        auto cmd = new string[objs.length];
        for (size_t i = 0; i < objs.length; ++i)
        {
            auto one = objs[i].toString;
            if (!one.find(' ').empty) one = ["{", one, "}"].join;
            cmd[i] = one;
        }
        _buf.put(cmd.join(' '));
        return this;
    }

    string flushLog()
    {
        import std.array : join;
        auto ret = _buf.data.join('\n');
        _buf.clear;
        return ret;
    }
private:
    import std.array : Appender;
    Appender!(string[]) _buf;
}

//------------------------------------------------------------------------------
/**
概要:
標準出力にコマンドの内容を表示した上で実行する。デバグ用。
 **/
auto logcall(TclCommand cmd)
{
    import std.stdio : writeln;
    writeln("% ", cmd.peek);
    cmd.call.result.to!string.writeln;
    return cmd.tcl;
}


//==============================================================================
private:
import std.utf : toUTFz;
alias toUTF8z = toUTFz!(const(char)*);

